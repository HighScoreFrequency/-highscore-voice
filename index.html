<script>
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();

  let mediaRecorder;
  let chunks = [];
  let mixedStream;
  let previewPlaying = false;
  let oscillatorStopWithFade = null;

  const recordBtn = document.getElementById('recordBtn');
  const stopBtn = document.getElementById('stopBtn');
  const resetBtn = document.getElementById('resetBtn');
  const previewTone = document.getElementById('previewTone');
  const audioPlayback = document.getElementById('audioPlayback');
  const downloadLink = document.getElementById('downloadLink');
  const frequencySelect = document.getElementById('frequencySelect');

  function createOscillator(freq, fadeIn = 1.5, fadeOut = 1.5) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const pan = audioCtx.createStereoPanner();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.02, now + fadeIn);

    osc.connect(pan).connect(gain);

    const stopWithFade = () => {
      const stopTime = audioCtx.currentTime + fadeOut;
      gain.gain.cancelScheduledValues(audioCtx.currentTime);
      gain.gain.setValueAtTime(gain.gain.value, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(0, stopTime);
      osc.stop(stopTime);
    };

    return { output: gain, oscillator: osc, stopWithFade };
  }

  previewTone.onclick = () => {
    const freq = parseFloat(frequencySelect.value);
    if (freq === 0) return;

    if (!previewPlaying) {
      const { output, oscillator, stopWithFade } = createOscillator(freq);
      output.connect(audioCtx.destination);
      oscillator.start();
      previewTone.dataset.previewOscillator = oscillator;
      previewTone.dataset.stopWithFade = stopWithFade;
      previewPlaying = true;
      previewTone.textContent = 'ðŸ›‘ Stop Preview';
    } else {
      const stopFn = previewTone.dataset.stopWithFade;
      if (stopFn && typeof stopFn === 'function') {
        stopFn();
      }
      previewPlaying = false;
      previewTone.textContent = 'ðŸ”Š Preview Tone';
    }
  };

  frequencySelect.addEventListener('change', () => {
    const freq = parseFloat(frequencySelect.value);
    previewTone.disabled = freq === 0;
    previewTone.textContent = freq === 0 ? 'ðŸ”‡ Preview Disabled' : 'ðŸ”Š Preview Tone';
  });

  previewTone.disabled = parseFloat(frequencySelect.value) === 0;
  previewTone.textContent = parseFloat(frequencySelect.value) === 0 ? 'ðŸ”‡ Preview Disabled' : 'ðŸ”Š Preview Tone';

  recordBtn.onclick = async () => {
    const freq = parseFloat(frequencySelect.value);
    let oscillatorNode = null;

    if (freq > 0) {
      const { output, oscillator, stopWithFade } = createOscillator(freq);
      oscillatorNode = output;
      oscillator.start();
      oscillatorStopWithFade = stopWithFade;
    } else {
      oscillatorStopWithFade = null;
    }

    try {
      const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const micSource = audioCtx.createMediaStreamSource(micStream);
      const dest = audioCtx.createMediaStreamDestination();

      micSource.connect(dest);
      if (oscillatorNode) oscillatorNode.connect(dest);

      mixedStream = dest.stream;
      mediaRecorder = new MediaRecorder(mixedStream);

      chunks = [];
      mediaRecorder.ondataavailable = e => chunks.push(e.data);
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/mp3' });
        const url = URL.createObjectURL(blob);

        audioPlayback.src = url;
        audioPlayback.style.display = 'block';

        const date = new Date().toISOString().split('T')[0];
        downloadLink.href = url;
        downloadLink.download = `highscore-frequency-${date}.mp3`;
        downloadLink.style.display = 'inline-block';
      };

      mediaRecorder.start();

      recordBtn.disabled = true;
      stopBtn.disabled = false;
    } catch (e) {
      alert('Mic access denied.');
    }
  };

  stopBtn.onclick = () => {
    mediaRecorder.stop();
    if (typeof oscillatorStopWithFade === 'function') {
      oscillatorStopWithFade();
    }
    recordBtn.disabled = false;
    stopBtn.disabled = true;
    resetBtn.disabled = false;
  };

  resetBtn.onclick = () => {
    audioPlayback.pause();
    audioPlayback.currentTime = 0;
    audioPlayback.src = '';
    audioPlayback.style.display = 'none';

    downloadLink.href = '';
    downloadLink.download = '';
    downloadLink.style.display = 'none';

    resetBtn.disabled = true;
  };
</script>
